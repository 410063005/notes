[category]: reading
[keywords]: 重构
[source]: --
[date]: 2014-10-25

# 封装集合
> 来自 p208 第8.11节

常常会在类中使用集合(collection)，比如 array、list、set或map等，通常也会提供针对集合的setter/getter。

getter不应该返回集合自身，因为这会让客户端有机会修改集合内容而集合的拥有者却对此一无所知(这是相当危险的，也容易出错！)。另一方面也表明向客户端暴露了过多的内部数据结构的信息。**应避免客户端直接操作对象内所保存的集合，并隐藏对象内跟客户端无关的数据结构**。

另外，不应为集合提供直接的setter，而是为集合提供添加/移除元素的方法。这样，集合的拥有者就可以控制集合元素的添加/移除了。

以上两点可以让集合被很好地封装起来，降低集合拥有者同客户端之间的耦合。

*定位SDK中的ScanResultExt类是很好的一个反倒，下周(2014-10-27)考虑如何使用以上技巧重构这个类*

---

注意，遇到以下两种情况时可能确实需要为集合提供setter：

+ 集合被初始化为 null
+ 使用另一个集合替换原有的集合

但这时最好将集合的setter名字从 setXXX() 修改为 initXXX() 或 replaceXXX()

# 以类取代类型码
> 来自 p219 第8.13节

类型码很常见，如果类型码的名字取得非常好，则代码的可读性还是很好的。问题是符号名终究是个别名，任何接受类型码作为参数的函数所期望的不过是一个数值，无法强制使用符号名，编译器无法进行有效的检查，不能保证只有合法的实例被创建出来，所以容易出现bug。

反过来，如果将类型码换成一个类，编译器就可以对这个进行类型检验。只要为这个类提供工厂函数，就**可以始终保证只有合法的实例才会被创建出来**。

以 Person 表示"人"，以其中的类型码表示"血型"：

	class Person {
		public static final int O = 0;
		public static final int A = 1;
		public static final int B = 2;
		public static final int AB = 3;

		private int _bloodGroup;

		public Person(int bloodGroup) {
			_bloodGroup = bloodGroup;
		}
	}

合法的 bloodGroup 只有 0、1、2、3 四个值，但编译器无法检查出 new Person(5) 这样的错误，这个错误导致生成非法的 Person 实例，成为一个潜在的bug。

对以上代码进行重构：

	class BloodGroup {
		public static final BloodGroup O = new BloodGroup(0);
		public static final BloodGroup A = new BloodGroup(1);
		public static final BloodGroup B = new BloodGroup(2);
		public static final BloodGroup AB = new BloodGroup(3);

		private final int _code;
		
		private BloodGroup(int code) {
			_code = code;
		}
	}

	class Person {
		private BloodGroup _bloodGroup;

		public Person(BloodGroup bloodGroup) {
			_bloodGroup = bloodGroup;
		}

	}

现在，不可能生成非法的 Person 实例了。

# 以子类取代类型码
> 来自 p223 第8.14节

如果类型码不会影响宿主类的行为，可以使用"以类取代类型码"，就像上面的那个例子那样。但如果类型码会影响宿主类的行为，那么最好的办法就是借助多态来处理变化行为。

一般来说，这种情况的标志就是像 switch 或 if-then-else 这样的条件表达式，都是检查类型码值，并根据不同的值执行不同的动作。

	class Employee {
		private int _type;
		
		static final int ENGINEER = 0;
		static final int SALESMAN = 1;
		static final int MANAGER = 2;
		
		Employee(int type) {
			_type = type;
		}
	}

重构成：

	abstract class Employee {
		abstract int getType();

		static Employee create(int type) {
			switch (type):
				case ENGINEER:
					return new Engineer();
				case SALESMAN:
					return Salesman();
				case MANAGER:
					return Manager();
				default:
					throw new IllegalArgumentException("Incorrect type code " + type);
		}
	}

这里也用到了 switch 语句，但它只用于决定创建何种对象，这样的 switch 是可以接受的。

# 以 State/Strategy 取代类型码
> 来自 p227 第8.15节

跟前面提到的 "以子类取代类型码" 很类似，但如果"类型码的值在对象生命周期中发生变化" 或某些原因导致 "宿主类不能被继承"，就需要使用这里的重构技巧了。

下面这个例子演示了这一重构技巧

这是[重构前的代码](../assets/01_重构_改善既有代码设计-Employee.java)

	public class Employee {
		private int _type;
		static final int ENGINEER = 0;
		static final int SALESMAN = 1;
		static final int MANAGER = 2;

		public Employee(int type) {
			_type = type;
		}

		int payAmount() {
			switch (_type) {
				case ENGINEER:
					return _monthlySalary;
				case SALESMAN:
					return _monthlySalary + _commission;
				case MANAGER:
					return _monthlySalary + _bonus;
				default:
					throw new RuntimeException("Incorrect Employee");
			}
		}

		int _monthlySalary;
		int _commission;
		int _bonus;
	}

这是[重构后的代码](../assets/01_重构_改善既有代码设计-Employee2.java)

	public class Employee2 {
		//	private int _type;
		
		// 5. 在源类中建立一个字段, 用以保存新建的状态对象
		private EmployeeType _type;

		public Employee2(int type) {
			setType(type);
		}

		// 1. 使用 getType() 将 _type 自我封装起来
		
		// 6. 调整源类中的查询类型码的函数, 将查询动作转发给状态对象
		public int getType() {
			return _type.getTypeCode();
		}
		
		// 7. 调整源类中负责为类型码设值的函数, 将一个恰当的状态子类对象赋值给"保存状态对象"的那个字段
		public void setType(int type) {
		//		this._type = type;
			this._type = EmployeeType.newType(type);
		}
		
		// 8. 使用 "Replace Conditional with Polymorphism" 处理 payAmount 方法
		int payAmount() {
		//		switch (getType()) {
		//			case ENGINEER:
		//				return _monthlySalary;
		//			case SALESMAN:
		//				return _monthlySalary + _commission;
		//			case MANAGER:
		//				return _monthlySalary + _bonus;
		//			default:
		//				throw new RuntimeException("Incorrect Employee");
		//		}
			return _type.payAmount();
		}

		int _monthlySalary;
		int _commission;
		int _bonus;
	}

	// 2. 新建一个类, 根据类型码的用途为它命名(State/Strategy对象)
	abstract class EmployeeType {
		static final int ENGINEER = 0;
		static final int SALESMAN = 1;
		static final int MANAGER = 2;
		
		int _monthlySalary;
		int _commission;
		int _bonus;
		
		// 4. 在超类中建立一个抽象的查询函数, 用以返回类型码
		abstract int getTypeCode();
		
		int payAmount() {
			switch (getTypeCode()) {
				case ENGINEER:
					return _monthlySalary;
				case SALESMAN:
					return _monthlySalary + _commission;
				case MANAGER:
					return _monthlySalary + _bonus;
				default:
					throw new RuntimeException("Incorrect Employee");
			}
		}
		
		static EmployeeType newType(int code) {
			switch (code) {
			case ENGINEER:
				return new Engineer();

			case SALESMAN:
				return new Salesman();

			case MANAGER:
				return new Manager();
			
			default:
				throw new IllegalArgumentException("Incorrect Employee code");
			}
		}
	}

	// 3. 这个state/strategy对象添加子类, 每个子类对应一种状态码
	class Engineer extends EmployeeType {

		@Override
		int getTypeCode() {
			return ENGINEER;
		}
	}

	class Salesman extends EmployeeType {

		@Override
		int getTypeCode() {
			return SALESMAN;
		}
	}

	class Manager extends EmployeeType {

		@Override
		int getTypeCode() {
			return MANAGER;
		}
	}

# 分解条件表达式 
> 来自 p238 第9.1节

程序之中复杂的条件逻辑是最常导致复杂度上升的地点之一。必须编写代码检查不同的条件分支，并根据不同的条件分支做不同的事件。这很容易导致相当长的函数。过长的函数可读性通常很差。

可以将复杂的条件逻辑分解成多个独立，根据每个代码的用途为分解而得到的新函数命名。好的函数名会让这一小段代码看上去就像注释那样清楚而明白。

# Replace Nested Conditional with Guard Clauses 
> 来自 p250 第9.5节

条件表达式通常有两种表现形式。第一种是：所有的分支都属于正常行为。第二种是：只有一种是正常行为，其他都是不常见的情况。前者应该使用形如 if-then-else 的条件表达式，表明你对 if 分支和 else 分支的同等重视。后者应先单独检查某个条件，并在该条件为真时立即从函数中返回。(这里的单独检查即为 Guard Clauses，原文翻译为卫语句)。
