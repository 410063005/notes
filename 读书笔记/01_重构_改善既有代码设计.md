[category]: reading
[keywords]: 重构
[source]: --
[date]: 2014-10-25

# 封装集合
> 来自 p208 第8.11节

常常会在类中使用集合(collection)，比如 array、list、set或map等，通常也会提供针对集合的setter/getter。

getter不应该返回集合自身，因为这会让客户端有机会修改集合内容而集合的拥有者却对此一无所知(这是相当危险的，也容易出错！)。另一方面也表明向客户端暴露了过多的内部数据结构的信息。**应避免客户端直接操作对象内所保存的集合，并隐藏对象内跟客户端无关的数据结构**。

另外，不应为集合提供直接的setter，而是为集合提供添加/移除元素的方法。这样，集合的拥有者就可以控制集合元素的添加/移除了。

以上两点可以让集合被很好地封装起来，降低集合拥有者同客户端之间的耦合。

*定位SDK中的ScanResultExt类是很好的一个反倒，下周(2014-10-27)考虑如何使用以上技巧重构这个类*

---

注意，遇到以下两种情况时可能确实需要为集合提供setter：

+ 集合被初始化为 null
+ 使用另一个集合替换原有的集合

但这时最好将集合的setter名字从 setXXX() 修改为 initXXX() 或 replaceXXX()

# 以类取代类型码
> 来自 p219 第8.13节

类型码很常见，如果类型码的名字取得非常好，则代码的可读性还是很好的。问题是符号名终究是个别名，任何接受类型码作为参数的函数所期望的不过是一个数值，无法强制使用符号名，编译器无法进行有效的检查，不能保证只有合法的实例被创建出来，所以容易出现bug。

反过来，如果将类型码换成一个类，编译器就可以对这个进行类型检验。只要为这个类提供工厂函数，就**可以始终保证只有合法的实例才会被创建出来**。

以 Person 表示"人"，以其中的类型码表示"血型"：

	class Person {
		public static final int O = 0;
		public static final int A = 1;
		public static final int B = 2;
		public static final int AB = 3;

		private int _bloodGroup;

		public Person(int bloodGroup) {
			_bloodGroup = bloodGroup;
		}
	}

合法的 bloodGroup 只有 0、1、2、3 四个值，但编译器无法检查出 new Person(5) 这样的错误，这个错误导致生成非法的 Person 实例，成为一个潜在的bug。

对以上代码进行重构：

	class BloodGroup {
		public static final BloodGroup O = new BloodGroup(0);
		public static final BloodGroup A = new BloodGroup(1);
		public static final BloodGroup B = new BloodGroup(2);
		public static final BloodGroup AB = new BloodGroup(3);

		private final int _code;
		
		private BloodGroup(int code) {
			_code = code;
		}
	}

	class Person {
		private BloodGroup _bloodGroup;

		public Person(BloodGroup bloodGroup) {
			_bloodGroup = bloodGroup;
		}

	}

现在，不可能生成非法的 Person 实例了。

# 以子类取代类型码
> 来自 p223 第8.14节

如果类型码不会影响宿主类的行为，可以使用"以类取代类型码"，就像上面的那个例子那样。但如果类型码会影响宿主类的行为，那么最好的办法就是借助多态来处理变化行为。

一般来说，这种情况的标志就是像 switch 或 if-then-else 这样的条件表达式，都是检查类型码值，并根据不同的值执行不同的动作。

	class Employee {
		private int _type;
		
		static final int ENGINEER = 0;
		static final int SALESMAN = 1;
		static final int MANAGER = 2;
		
		Employee(int type) {
			_type = type;
		}
	}

重构成：

	abstract class Employee {
		abstract int getType();

		static Employee create(int type) {
			switch (type):
				case ENGINEER:
					return new Engineer();
				case SALESMAN:
					return Salesman();
				case MANAGER:
					return Manager();
				default:
					throw new IllegalArgumentException("Incorrect type code " + type);
		}
	}

这里也用到了 switch 语句，但它只用于决定创建何种对象，这样的 switch 是可以接受的。

# 以 State/Strategy 取代类型码
> 来自 p227 第8.15节
跟前面提到的 "以子类取代类型码" 很类似，但如果"类型码的值在对象生命周期中发生变化" 或某些原因导致 "宿主类不能被继承"，就需要使用这里的重构技巧了。


